/*
 * generated by Xtext 2.21.0
 */
package org.eclipse.efbt.aorta.serializer;

import aorta_program.Aorta_programPackage;
import aorta_program.Program;
import base_column_structured_data.BaseCellWithEnumeratedValue;
import base_column_structured_data.BaseCellWithValue;
import base_column_structured_data.BaseColumnStructuredData;
import base_column_structured_data.BaseRowData;
import base_column_structured_data.Base_column_structured_dataPackage;
import column_structured_data.ColumnStructuredData;
import column_structured_data.Column_structured_dataPackage;
import column_structures.Column;
import column_structures.ColumnDataType;
import column_structures.ColumnDomain;
import column_structures.ColumnDomainModule;
import column_structures.ColumnStructureModule;
import column_structures.ColumnStructuredEntity;
import column_structures.Column_structuresPackage;
import column_structures.EnumMember;
import com.google.inject.Inject;
import execution_environments.Execution_environmentsPackage;
import execution_environments.TestExecutionEnvironment;
import functionality_module.DataProcessingFunctionalityModule;
import functionality_module.FunctionalityModule;
import functionality_module.FunctionalityModuleModule;
import functionality_module.FunctionalityModuleSet;
import functionality_module.Functionality_modulePackage;
import functionality_module.LeafFunctionalityModule;
import functionality_module.OutputCreationFunctionalityModule;
import functionality_module.ParallelFunctionalityModule;
import functionality_module.ReadDataSourceFunctionalityModule;
import functionality_module.ScenarioSetFunctionalityModule;
import functionality_module.SerialFunctionalityModule;
import functionality_module.ValidationFunctionalityModule;
import input_data_structures.InputDatastructureModule;
import input_data_structures.Input_data_structuresPackage;
import java.util.Set;
import module_management.ModuleDependencies;
import module_management.ModuleDependency;
import module_management.ModuleLongName;
import module_management.Module_managementPackage;
import org.eclipse.efbt.aorta.services.AortaGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import output_data_structures.OutputDataStructureModule;
import output_data_structures.Output_data_structuresPackage;
import report_structures.RegReport;
import report_structures.RegReportCell;
import report_structures.RegReportCellValue;
import report_structures.RegReportModule;
import report_structures.ReportGroup;
import report_structures.Report_structuresPackage;
import requirements_artefacts.InputType;
import requirements_artefacts.InputTypeModule;
import requirements_artefacts.Requirements_artefactsPackage;
import requirements_text.AllowedTypes;
import requirements_text.RequirementType;
import requirements_text.RequirementsModule;
import requirements_text.RequirementsSectionImage;
import requirements_text.RequirementsSectionLinkWithText;
import requirements_text.RequirementsSectionText;
import requirements_text.Requirements_textPackage;
import requirements_text.TitledRequirementsSection;
import scenarios.Scenario;
import scenarios.ScenarioSet;
import scenarios.ScenariosPackage;
import test.DataSetResults;
import test.E2ETest;
import test.ReportCellResults;
import test.Result;
import test.TestModule;
import test.TestPackage;
import test_definition.ClauseText;
import test_definition.E2ETestDefinition;
import test_definition.Given;
import test_definition.Param;
import test_definition.TestContraints;
import test_definition.TestDefinition;
import test_definition.TestDefinitionModule;
import test_definition.TestTemplate;
import test_definition.TestTemplateModule;
import test_definition.Test_definitionPackage;
import test_definition.Then;
import test_definition.UnitTestDefinition;
import test_definition.When;
import test_input_data.StructuredFile;
import test_input_data.TestColumnStructuredData;
import test_input_data.TestInputData;
import test_input_data.TestStrucuredFileData;
import test_input_data.Test_input_dataPackage;

@SuppressWarnings("all")
public class AortaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AortaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Aorta_programPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Aorta_programPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			}
		else if (epackage == Base_column_structured_dataPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Base_column_structured_dataPackage.BASE_CELL_WITH_ENUMERATED_VALUE:
				sequence_BaseCellWithEnumeratedValue(context, (BaseCellWithEnumeratedValue) semanticObject); 
				return; 
			case Base_column_structured_dataPackage.BASE_CELL_WITH_VALUE:
				sequence_BaseCellWithValue(context, (BaseCellWithValue) semanticObject); 
				return; 
			case Base_column_structured_dataPackage.BASE_COLUMN_STRUCTURED_DATA:
				sequence_BaseColumnStructuredData(context, (BaseColumnStructuredData) semanticObject); 
				return; 
			case Base_column_structured_dataPackage.BASE_ROW_DATA:
				sequence_BaseRowData(context, (BaseRowData) semanticObject); 
				return; 
			}
		else if (epackage == Column_structured_dataPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Column_structured_dataPackage.COLUMN_STRUCTURED_DATA:
				sequence_ColumnStructuredData(context, (ColumnStructuredData) semanticObject); 
				return; 
			}
		else if (epackage == Column_structuresPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Column_structuresPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case Column_structuresPackage.COLUMN_DATA_TYPE:
				sequence_ColumnDataType(context, (ColumnDataType) semanticObject); 
				return; 
			case Column_structuresPackage.COLUMN_DOMAIN:
				sequence_ColumnDomain(context, (ColumnDomain) semanticObject); 
				return; 
			case Column_structuresPackage.COLUMN_DOMAIN_MODULE:
				sequence_ColumnDomainModule(context, (ColumnDomainModule) semanticObject); 
				return; 
			case Column_structuresPackage.COLUMN_STRUCTURE_MODULE:
				sequence_ColumnStructureModule(context, (ColumnStructureModule) semanticObject); 
				return; 
			case Column_structuresPackage.COLUMN_STRUCTURED_ENTITY:
				sequence_ColumnStructuredEntity(context, (ColumnStructuredEntity) semanticObject); 
				return; 
			case Column_structuresPackage.ENUM_MEMBER:
				sequence_EnumMember(context, (EnumMember) semanticObject); 
				return; 
			}
		else if (epackage == EcorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EcorePackage.EOBJECT:
				sequence_EObject(context, (EObject) semanticObject); 
				return; 
			}
		else if (epackage == Execution_environmentsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Execution_environmentsPackage.TEST_EXECUTION_ENVIRONMENT:
				sequence_TestExecutionEnvironment(context, (TestExecutionEnvironment) semanticObject); 
				return; 
			}
		else if (epackage == Functionality_modulePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Functionality_modulePackage.DATA_PROCESSING_FUNCTIONALITY_MODULE:
				sequence_DataProcessingFunctionalityModule(context, (DataProcessingFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.FUNCTIONALITY_MODULE:
				sequence_FunctionalityModule_Impl(context, (FunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.FUNCTIONALITY_MODULE_MODULE:
				sequence_FunctionalityModuleModule(context, (FunctionalityModuleModule) semanticObject); 
				return; 
			case Functionality_modulePackage.FUNCTIONALITY_MODULE_SET:
				sequence_FunctionalityModuleSet_Impl(context, (FunctionalityModuleSet) semanticObject); 
				return; 
			case Functionality_modulePackage.LEAF_FUNCTIONALITY_MODULE:
				sequence_LeafFunctionalityModule_Impl(context, (LeafFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.OUTPUT_CREATION_FUNCTIONALITY_MODULE:
				sequence_OutputCreationFunctionalityModule(context, (OutputCreationFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.PARALLEL_FUNCTIONALITY_MODULE:
				sequence_ParallelFunctionalityModule(context, (ParallelFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.READ_DATA_SOURCE_FUNCTIONALITY_MODULE:
				sequence_ReadDataSourceFunctionalityModule(context, (ReadDataSourceFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.SCENARIO_SET_FUNCTIONALITY_MODULE:
				sequence_ScenarioSetFunctionalityModule(context, (ScenarioSetFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.SERIAL_FUNCTIONALITY_MODULE:
				sequence_SerialFunctionalityModule(context, (SerialFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.VALIDATION_FUNCTIONALITY_MODULE:
				sequence_ValidationFunctionalityModule(context, (ValidationFunctionalityModule) semanticObject); 
				return; 
			}
		else if (epackage == Input_data_structuresPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Input_data_structuresPackage.INPUT_DATASTRUCTURE_MODULE:
				sequence_InputDatastructureModule(context, (InputDatastructureModule) semanticObject); 
				return; 
			}
		else if (epackage == Module_managementPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Module_managementPackage.MODULE_DEPENDENCIES:
				sequence_ModuleDependencies(context, (ModuleDependencies) semanticObject); 
				return; 
			case Module_managementPackage.MODULE_DEPENDENCY:
				sequence_ModuleDependency(context, (ModuleDependency) semanticObject); 
				return; 
			case Module_managementPackage.MODULE_LONG_NAME:
				sequence_ModuleLongName(context, (ModuleLongName) semanticObject); 
				return; 
			}
		else if (epackage == Output_data_structuresPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Output_data_structuresPackage.OUTPUT_DATA_STRUCTURE_MODULE:
				sequence_OutputDataStructureModule(context, (OutputDataStructureModule) semanticObject); 
				return; 
			}
		else if (epackage == Report_structuresPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Report_structuresPackage.REG_REPORT:
				sequence_RegReport(context, (RegReport) semanticObject); 
				return; 
			case Report_structuresPackage.REG_REPORT_CELL:
				sequence_RegReportCell(context, (RegReportCell) semanticObject); 
				return; 
			case Report_structuresPackage.REG_REPORT_CELL_VALUE:
				sequence_RegReportCellValue(context, (RegReportCellValue) semanticObject); 
				return; 
			case Report_structuresPackage.REG_REPORT_MODULE:
				sequence_RegReportModule(context, (RegReportModule) semanticObject); 
				return; 
			case Report_structuresPackage.REPORT_GROUP:
				sequence_ReportGroup(context, (ReportGroup) semanticObject); 
				return; 
			}
		else if (epackage == Requirements_artefactsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Requirements_artefactsPackage.INPUT_TYPE:
				sequence_InputType(context, (InputType) semanticObject); 
				return; 
			case Requirements_artefactsPackage.INPUT_TYPE_MODULE:
				sequence_InputTypeModule(context, (InputTypeModule) semanticObject); 
				return; 
			}
		else if (epackage == Requirements_textPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Requirements_textPackage.ALLOWED_TYPES:
				sequence_AllowedTypes(context, (AllowedTypes) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENT_TYPE:
				sequence_RequirementType(context, (RequirementType) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENTS_MODULE:
				sequence_RequirementsModule(context, (RequirementsModule) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENTS_SECTION_IMAGE:
				sequence_RequirementsSectionImage(context, (RequirementsSectionImage) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENTS_SECTION_LINK_WITH_TEXT:
				sequence_RequirementsSectionLinkWithText(context, (RequirementsSectionLinkWithText) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENTS_SECTION_TEXT:
				sequence_RequirementsSectionText(context, (RequirementsSectionText) semanticObject); 
				return; 
			case Requirements_textPackage.TITLED_REQUIREMENTS_SECTION:
				sequence_TitledRequirementsSection(context, (TitledRequirementsSection) semanticObject); 
				return; 
			}
		else if (epackage == ScenariosPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ScenariosPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case ScenariosPackage.SCENARIO_SET:
				sequence_ScenarioSet(context, (ScenarioSet) semanticObject); 
				return; 
			}
		else if (epackage == TestPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TestPackage.DATA_SET_RESULTS:
				sequence_DataSetResults(context, (DataSetResults) semanticObject); 
				return; 
			case TestPackage.E2E_TEST:
				sequence_E2ETest(context, (E2ETest) semanticObject); 
				return; 
			case TestPackage.REPORT_CELL_RESULTS:
				sequence_ReportCellResults(context, (ReportCellResults) semanticObject); 
				return; 
			case TestPackage.RESULT:
				sequence_Result_Impl(context, (Result) semanticObject); 
				return; 
			case TestPackage.TEST_MODULE:
				sequence_TestModule(context, (TestModule) semanticObject); 
				return; 
			}
		else if (epackage == Test_definitionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Test_definitionPackage.CLAUSE_TEXT:
				sequence_ClauseText(context, (ClauseText) semanticObject); 
				return; 
			case Test_definitionPackage.E2E_TEST_DEFINITION:
				sequence_E2ETestDefinition(context, (E2ETestDefinition) semanticObject); 
				return; 
			case Test_definitionPackage.GIVEN:
				sequence_Given(context, (Given) semanticObject); 
				return; 
			case Test_definitionPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_CONTRAINTS:
				sequence_TestContraints(context, (TestContraints) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_DEFINITION:
				sequence_TestDefinition_Impl(context, (TestDefinition) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_DEFINITION_MODULE:
				sequence_TestDefinitionModule(context, (TestDefinitionModule) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_TEMPLATE:
				sequence_TestTemplate(context, (TestTemplate) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_TEMPLATE_MODULE:
				sequence_TestTemplateModule(context, (TestTemplateModule) semanticObject); 
				return; 
			case Test_definitionPackage.THEN:
				sequence_Then(context, (Then) semanticObject); 
				return; 
			case Test_definitionPackage.UNIT_TEST_DEFINITION:
				sequence_UnitTestDefinition(context, (UnitTestDefinition) semanticObject); 
				return; 
			case Test_definitionPackage.WHEN:
				sequence_When(context, (When) semanticObject); 
				return; 
			}
		else if (epackage == Test_input_dataPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Test_input_dataPackage.STRUCTURED_FILE:
				sequence_StructuredFile(context, (StructuredFile) semanticObject); 
				return; 
			case Test_input_dataPackage.TEST_COLUMN_STRUCTURED_DATA:
				sequence_TestColumnStructuredData(context, (TestColumnStructuredData) semanticObject); 
				return; 
			case Test_input_dataPackage.TEST_INPUT_DATA:
				sequence_TestInputData_Impl(context, (TestInputData) semanticObject); 
				return; 
			case Test_input_dataPackage.TEST_STRUCURED_FILE_DATA:
				sequence_TestStrucuredFileData(context, (TestStrucuredFileData) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AllowedTypes returns AllowedTypes
	 *
	 * Constraint:
	 *     (allowedTypes+=RequirementType allowedTypes+=RequirementType*)?
	 */
	protected void sequence_AllowedTypes(ISerializationContext context, AllowedTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BaseCell returns BaseCellWithEnumeratedValue
	 *     BaseCellWithEnumeratedValue returns BaseCellWithEnumeratedValue
	 *
	 * Constraint:
	 *     (cellID=EString column=[Column|QualifiedName]? value=[EnumMember|QualifiedName]?)
	 */
	protected void sequence_BaseCellWithEnumeratedValue(ISerializationContext context, BaseCellWithEnumeratedValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BaseCell returns BaseCellWithValue
	 *     BaseCellWithValue returns BaseCellWithValue
	 *
	 * Constraint:
	 *     (cellID=EString value=EString? column=[Column|QualifiedName]?)
	 */
	protected void sequence_BaseCellWithValue(ISerializationContext context, BaseCellWithValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BaseColumnStructuredData returns BaseColumnStructuredData
	 *
	 * Constraint:
	 *     (name=EString cube=[ColumnStructuredEntity|QualifiedName]? (rows+=BaseRowData rows+=BaseRowData*)?)
	 */
	protected void sequence_BaseColumnStructuredData(ISerializationContext context, BaseColumnStructuredData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BaseRowData returns BaseRowData
	 *
	 * Constraint:
	 *     (rowID=EString (cells+=BaseCell cells+=BaseCell*)?)
	 */
	protected void sequence_BaseRowData(ISerializationContext context, BaseRowData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClauseText returns ClauseText
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ClauseText(ISerializationContext context, ClauseText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Test_definitionPackage.Literals.CLAUSE_TEXT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Test_definitionPackage.Literals.CLAUSE_TEXT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClauseTextAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ColumnDataType returns ColumnDataType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ColumnDataType(ISerializationContext context, ColumnDataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Column_structuresPackage.Literals.COLUMN_DATA_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Column_structuresPackage.Literals.COLUMN_DATA_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnDataTypeAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ColumnDomainModule returns ColumnDomainModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (columnDomains+=ColumnDomain columnDomains+=ColumnDomain*)?
	 *     )
	 */
	protected void sequence_ColumnDomainModule(ISerializationContext context, ColumnDomainModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnDomain returns ColumnDomain
	 *
	 * Constraint:
	 *     (isEnumerated?='isEnumerated'? name=EString (enumMembers+=EnumMember enumMembers+=EnumMember*)? dataType=ColumnDataType?)
	 */
	protected void sequence_ColumnDomain(ISerializationContext context, ColumnDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnStructureModule returns ColumnStructureModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (columnStructures+=ColumnStructuredEntity columnStructures+=ColumnStructuredEntity*)?
	 *     )
	 */
	protected void sequence_ColumnStructureModule(ISerializationContext context, ColumnStructureModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnStructuredData returns ColumnStructuredData
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ColumnStructuredData(ISerializationContext context, ColumnStructuredData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Column_structured_dataPackage.Literals.COLUMN_STRUCTURED_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Column_structured_dataPackage.Literals.COLUMN_STRUCTURED_DATA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnStructuredDataAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ColumnStructuredEntity returns ColumnStructuredEntity
	 *
	 * Constraint:
	 *     (name=EString (column+=Column column+=Column*)?)
	 */
	protected void sequence_ColumnStructuredEntity(ISerializationContext context, ColumnStructuredEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (isIdentifier?='isIdentifier'? isMandatory?='isMandatory'? name=EString domain=[ColumnDomain|QualifiedName]?)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns DataProcessingFunctionalityModule
	 *     DataProcessingFunctionalityModule returns DataProcessingFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_DataProcessingFunctionalityModule(ISerializationContext context, DataProcessingFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns DataSetResults
	 *     DataSetResults returns DataSetResults
	 *
	 * Constraint:
	 *     (expectedResults+=ColumnStructuredData expectedResults+=ColumnStructuredData*)?
	 */
	protected void sequence_DataSetResults(ISerializationContext context, DataSetResults semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDefinition returns E2ETestDefinition
	 *     E2ETestDefinition returns E2ETestDefinition
	 *
	 * Constraint:
	 *     (name=EString testContraints=[TestContraints|QualifiedName]? given=Given? when=When? then=Then?)
	 */
	protected void sequence_E2ETestDefinition(ISerializationContext context, E2ETestDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E2ETest returns E2ETest
	 *
	 * Constraint:
	 *     (name=EString testDefinition=[E2ETestDefinition|QualifiedName]? inputData=TestInputData? expectedResults=Result?)
	 */
	protected void sequence_E2ETest(ISerializationContext context, E2ETest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EObject returns EObject
	 *
	 * Constraint:
	 *     {EObject}
	 */
	protected void sequence_EObject(ISerializationContext context, EObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumMember returns EnumMember
	 *
	 * Constraint:
	 *     (name=EString code=EString?)
	 */
	protected void sequence_EnumMember(ISerializationContext context, EnumMember semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModuleModule returns FunctionalityModuleModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (FunctionalityModules+=FunctionalityModule FunctionalityModules+=FunctionalityModule*)?
	 *     )
	 */
	protected void sequence_FunctionalityModuleModule(ISerializationContext context, FunctionalityModuleModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns FunctionalityModuleSet
	 *     FunctionalityModuleSet_Impl returns FunctionalityModuleSet
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? 
	 *         scenario=[Scenario|QualifiedName]? 
	 *         scenarioSet=ScenarioSet? 
	 *         (subTransformationsAndSchemes+=FunctionalityModule subTransformationsAndSchemes+=FunctionalityModule*)?
	 *     )
	 */
	protected void sequence_FunctionalityModuleSet_Impl(ISerializationContext context, FunctionalityModuleSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns FunctionalityModule
	 *     FunctionalityModule_Impl returns FunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_FunctionalityModule_Impl(ISerializationContext context, FunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Given returns Given
	 *
	 * Constraint:
	 *     (
	 *         text=[ClauseText|QualifiedName]? 
	 *         (regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName] regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName]*)? 
	 *         (params+=Param params+=Param*)?
	 *     )
	 */
	protected void sequence_Given(ISerializationContext context, Given semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputDatastructureModule returns InputDatastructureModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName?
	 *     )
	 */
	protected void sequence_InputDatastructureModule(ISerializationContext context, InputDatastructureModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputTypeModule returns InputTypeModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (inputTypes+=InputType inputTypes+=InputType*)?
	 *     )
	 */
	protected void sequence_InputTypeModule(ISerializationContext context, InputTypeModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputType returns InputType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_InputType(ISerializationContext context, InputType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Requirements_artefactsPackage.Literals.INPUT_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Requirements_artefactsPackage.Literals.INPUT_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTypeAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns LeafFunctionalityModule
	 *     LeafFunctionalityModule_Impl returns LeafFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_LeafFunctionalityModule_Impl(ISerializationContext context, LeafFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleDependencies returns ModuleDependencies
	 *
	 * Constraint:
	 *     (theModules+=ModuleDependency theModules+=ModuleDependency*)?
	 */
	protected void sequence_ModuleDependencies(ISerializationContext context, ModuleDependencies semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleDependency returns ModuleDependency
	 *
	 * Constraint:
	 *     (moduleName=EString? moduleVersion=EString? theModule=[Module|QualifiedName]? longName=[ModuleLongName|QualifiedName]?)
	 */
	protected void sequence_ModuleDependency(ISerializationContext context, ModuleDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleLongName returns ModuleLongName
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ModuleLongName(ISerializationContext context, ModuleLongName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Module_managementPackage.Literals.MODULE_LONG_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Module_managementPackage.Literals.MODULE_LONG_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleLongNameAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns OutputCreationFunctionalityModule
	 *     OutputCreationFunctionalityModule returns OutputCreationFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_OutputCreationFunctionalityModule(ISerializationContext context, OutputCreationFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputDataStructureModule returns OutputDataStructureModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName?
	 *     )
	 */
	protected void sequence_OutputDataStructureModule(ISerializationContext context, OutputDataStructureModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns ParallelFunctionalityModule
	 *     ParallelFunctionalityModule returns ParallelFunctionalityModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? 
	 *         scenario=[Scenario|QualifiedName]? 
	 *         scenarioSet=ScenarioSet? 
	 *         (subTransformationsAndSchemes+=FunctionalityModule subTransformationsAndSchemes+=FunctionalityModule*)?
	 *     )
	 */
	protected void sequence_ParallelFunctionalityModule(ISerializationContext context, ParallelFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     param=[EObject|QualifiedName]?
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         domainModule=ColumnDomainModule? 
	 *         requirements=RequirementsModule? 
	 *         input_structures=ColumnStructureModule? 
	 *         reportStructures=RegReportModule? 
	 *         testDefinitions=TestDefinitionModule? 
	 *         tests=TestModule? 
	 *         requirementsArtefacts=InputTypeModule? 
	 *         testTemplates=TestTemplateModule? 
	 *         testConstriants=TestContraints? 
	 *         functionalityModules=FunctionalityModuleModule?
	 *     )
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns ReadDataSourceFunctionalityModule
	 *     ReadDataSourceFunctionalityModule returns ReadDataSourceFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_ReadDataSourceFunctionalityModule(ISerializationContext context, ReadDataSourceFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegReportCellValue returns RegReportCellValue
	 *
	 * Constraint:
	 *     (value=EString? cell=[RegReportCell|QualifiedName]?)
	 */
	protected void sequence_RegReportCellValue(ISerializationContext context, RegReportCellValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegReportCell returns RegReportCell
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_RegReportCell(ISerializationContext context, RegReportCell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Report_structuresPackage.Literals.REG_REPORT_CELL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Report_structuresPackage.Literals.REG_REPORT_CELL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegReportCellAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegReportModule returns RegReportModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (reportGroups+=ReportGroup reportGroups+=ReportGroup*)?
	 *     )
	 */
	protected void sequence_RegReportModule(ISerializationContext context, RegReportModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegReport returns RegReport
	 *
	 * Constraint:
	 *     (name=EString (cells+=RegReportCell cells+=RegReportCell*)?)
	 */
	protected void sequence_RegReport(ISerializationContext context, RegReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns ReportCellResults
	 *     ReportCellResults returns ReportCellResults
	 *
	 * Constraint:
	 *     (reportCellValues+=RegReportCellValue reportCellValues+=RegReportCellValue*)?
	 */
	protected void sequence_ReportCellResults(ISerializationContext context, ReportCellResults semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReportGroup returns ReportGroup
	 *
	 * Constraint:
	 *     (name=EString (regReports+=RegReport regReports+=RegReport*)?)
	 */
	protected void sequence_ReportGroup(ISerializationContext context, ReportGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementType returns RequirementType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_RequirementType(ISerializationContext context, RequirementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Requirements_textPackage.Literals.REQUIREMENT_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Requirements_textPackage.Literals.REQUIREMENT_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequirementTypeAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsModule returns RequirementsModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (rules+=TitledRequirementsSection rules+=TitledRequirementsSection*)? 
	 *         allowedtypes=AllowedTypes?
	 *     )
	 */
	protected void sequence_RequirementsModule(ISerializationContext context, RequirementsModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsSection returns RequirementsSectionImage
	 *     RequirementsSectionImage returns RequirementsSectionImage
	 *
	 * Constraint:
	 *     (name=EString style=EString? uri=EString?)
	 */
	protected void sequence_RequirementsSectionImage(ISerializationContext context, RequirementsSectionImage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsSection returns RequirementsSectionLinkWithText
	 *     RequirementsSectionLinkWithText returns RequirementsSectionLinkWithText
	 *
	 * Constraint:
	 *     (name=EString linkText=EString? subsection=EString? linkedRuleSection=[TitledRequirementsSection|QualifiedName]?)
	 */
	protected void sequence_RequirementsSectionLinkWithText(ISerializationContext context, RequirementsSectionLinkWithText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsSection returns RequirementsSectionText
	 *     RequirementsSectionText returns RequirementsSectionText
	 *
	 * Constraint:
	 *     (name=EString text=EString?)
	 */
	protected void sequence_RequirementsSectionText(ISerializationContext context, RequirementsSectionText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns Result
	 *     Result_Impl returns Result
	 *
	 * Constraint:
	 *     {Result}
	 */
	protected void sequence_Result_Impl(ISerializationContext context, Result semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns ScenarioSetFunctionalityModule
	 *     ScenarioSetFunctionalityModule returns ScenarioSetFunctionalityModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? 
	 *         scenario=[Scenario|QualifiedName]? 
	 *         scenarioSet=ScenarioSet? 
	 *         (subTransformationsAndSchemes+=FunctionalityModule subTransformationsAndSchemes+=FunctionalityModule*)? 
	 *         scenarioSetChoice=ScenarioSet?
	 *     )
	 */
	protected void sequence_ScenarioSetFunctionalityModule(ISerializationContext context, ScenarioSetFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScenarioSet returns ScenarioSet
	 *
	 * Constraint:
	 *     (name=EString (scenarios+=Scenario scenarios+=Scenario*)?)
	 */
	protected void sequence_ScenarioSet(ISerializationContext context, ScenarioSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScenariosPackage.Literals.SCENARIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScenariosPackage.Literals.SCENARIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScenarioAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns SerialFunctionalityModule
	 *     SerialFunctionalityModule returns SerialFunctionalityModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? 
	 *         scenario=[Scenario|QualifiedName]? 
	 *         scenarioSet=ScenarioSet? 
	 *         (subTransformationsAndSchemes+=FunctionalityModule subTransformationsAndSchemes+=FunctionalityModule*)?
	 *     )
	 */
	protected void sequence_SerialFunctionalityModule(ISerializationContext context, SerialFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructuredFile returns StructuredFile
	 *
	 * Constraint:
	 *     fileLocation=EString?
	 */
	protected void sequence_StructuredFile(ISerializationContext context, StructuredFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestInputData returns TestColumnStructuredData
	 *     TestColumnStructuredData returns TestColumnStructuredData
	 *
	 * Constraint:
	 *     (name=EString (sourceTableData+=BaseColumnStructuredData sourceTableData+=BaseColumnStructuredData*)?)
	 */
	protected void sequence_TestColumnStructuredData(ISerializationContext context, TestColumnStructuredData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestContraints returns TestContraints
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         template=[TestTemplate|QualifiedName]? 
	 *         (givenParams+=Param givenParams+=Param*)? 
	 *         (whenParams+=Param whenParams+=Param*)? 
	 *         (thenParams+=Param thenParams+=Param*)?
	 *     )
	 */
	protected void sequence_TestContraints(ISerializationContext context, TestContraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDefinitionModule returns TestDefinitionModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (testDefinitions+=TestDefinition testDefinitions+=TestDefinition*)?
	 *     )
	 */
	protected void sequence_TestDefinitionModule(ISerializationContext context, TestDefinitionModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDefinition returns TestDefinition
	 *     TestDefinition_Impl returns TestDefinition
	 *
	 * Constraint:
	 *     (name=EString testContraints=[TestContraints|QualifiedName]? given=Given? when=When? then=Then?)
	 */
	protected void sequence_TestDefinition_Impl(ISerializationContext context, TestDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestExecutionEnvironment returns TestExecutionEnvironment
	 *
	 * Constraint:
	 *     (name=EString inputStructures=[InputDatastructureModule|QualifiedName]? outputStructuresModule=[OutputDataStructureModule|QualifiedName]?)
	 */
	protected void sequence_TestExecutionEnvironment(ISerializationContext context, TestExecutionEnvironment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestInputData returns TestInputData
	 *     TestInputData_Impl returns TestInputData
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_TestInputData_Impl(ISerializationContext context, TestInputData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Test_input_dataPackage.Literals.TEST_INPUT_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Test_input_dataPackage.Literals.TEST_INPUT_DATA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestInputData_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TestModule returns TestModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         executionEnvironment=[TestExecutionEnvironment|QualifiedName]? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (tests+=E2ETest tests+=E2ETest*)?
	 *     )
	 */
	protected void sequence_TestModule(ISerializationContext context, TestModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestInputData returns TestStrucuredFileData
	 *     TestStrucuredFileData returns TestStrucuredFileData
	 *
	 * Constraint:
	 *     (name=EString (testFileData+=StructuredFile testFileData+=StructuredFile*)?)
	 */
	protected void sequence_TestStrucuredFileData(ISerializationContext context, TestStrucuredFileData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestTemplateModule returns TestTemplateModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (templates+=TestTemplate templates+=TestTemplate*)?
	 *     )
	 */
	protected void sequence_TestTemplateModule(ISerializationContext context, TestTemplateModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestTemplate returns TestTemplate
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         givenText=ClauseText? 
	 *         whenText=ClauseText? 
	 *         thenText=ClauseText? 
	 *         (givenParams+=Param givenParams+=Param*)? 
	 *         (whenParams+=Param whenParams+=Param*)? 
	 *         (thenParams+=Param thenParams+=Param*)?
	 *     )
	 */
	protected void sequence_TestTemplate(ISerializationContext context, TestTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Then returns Then
	 *
	 * Constraint:
	 *     (
	 *         text=[ClauseText|QualifiedName]? 
	 *         (regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName] regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName]*)? 
	 *         (params+=Param params+=Param*)?
	 *     )
	 */
	protected void sequence_Then(ISerializationContext context, Then semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsSection returns TitledRequirementsSection
	 *     TitledRequirementsSection returns TitledRequirementsSection
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         title=EString? 
	 *         referencingSections=[RequirementsSectionLinkWithText|QualifiedName]? 
	 *         requirementsType=[RequirementType|QualifiedName] 
	 *         (sections+=RequirementsSection sections+=RequirementsSection*)?
	 *     )
	 */
	protected void sequence_TitledRequirementsSection(ISerializationContext context, TitledRequirementsSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDefinition returns UnitTestDefinition
	 *     UnitTestDefinition returns UnitTestDefinition
	 *
	 * Constraint:
	 *     (name=EString testContraints=[TestContraints|QualifiedName]? given=Given? when=When? then=Then?)
	 */
	protected void sequence_UnitTestDefinition(ISerializationContext context, UnitTestDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns ValidationFunctionalityModule
	 *     ValidationFunctionalityModule returns ValidationFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_ValidationFunctionalityModule(ISerializationContext context, ValidationFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     When returns When
	 *
	 * Constraint:
	 *     (
	 *         text=[ClauseText|QualifiedName]? 
	 *         (regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName] regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName]*)? 
	 *         (params+=Param params+=Param*)?
	 *     )
	 */
	protected void sequence_When(ISerializationContext context, When semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
